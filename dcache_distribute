#!/usr/bin/env python
# Tool to distribute all datasets on dCache - uses simple greedy algorithm
# by Fred Stober (stober@cern.ch)

import sys, os, copy
from toolKIT.utils import expath, progress, get_cached
from toolKIT.chimera import dCacheInfo, get_chimera_data
from toolKIT.dCache import get_pool_infos
from toolKIT.dCache_distribute import filterMoveable, writeTransferCommands, writeTransferFile
from toolKIT.lfntools import fn2ddn
from toolKIT.monitoring import happyface_upload

dCacheWebHost = 'http://192.108.45.36:2288'

# Play back old storage 
#from toolKIT.chimera import cache_chimera_data
#cache_chimera_data(expath('~/storage_scratch/chimera-dump'),
#	expath('~/storage_scratch/storage-information'), 201407160705)
chimera_path = expath('~/storage_scratch/chimera-dump/current')

def getPoolOverview():
	result_flat = {}
	result_total = 0
	for pool in get_pool_infos(dCacheWebHost):
		if 'space' not in pool:
			print 'Pool %s skipped - no space information available!', pool['name']
			continue
#		if not poolFilter(pool):
#			continue
		if not pool['name'].endswith('D_cms'):
			continue
		pool['free'] = pool['space']['free'] + pool['space']['removable']
		result_flat[pool['name']] = pool
		result_total += pool['space']['total']
	return (result_flat, result_total)

# Return dictionary ds -> {'files': ds files, 'size': ds size, <pool>: size on pool, ...}
def getDataPackagesBefore():
	result = {}
	iter_chimera = get_chimera_data(chimera_path)
	for entry in filterMoveable(progress(iter_chimera)):
		ds = fn2ddn(entry[dCacheInfo.pfn])
		ds_dict = result.setdefault(ds, {})
		ds_dict['files'] = ds_dict.get('files', 0) + 1
		entry_locations = entry.get(dCacheInfo.location, [])
		ds_dict['size'] = ds_dict.get('size', 0) + entry[dCacheInfo.size] * len(entry_locations)
		for loc in entry_locations:
			ds_dict[loc] = ds_dict.get(loc, 0) + entry[dCacheInfo.size]
	return result

# Return dictionary ds -> {<pool>: size delta to reach optimum, ...}
def getPoolTargetSize(packages, pools):
	result = {}
	for ds in sorted(packages, key = lambda k: packages[k]['size']):
		if '/disk-only/' not in ds:
			continue
		ignore = False
		# IGNORED, 'unmerged']:#, 'disk-only/dev', '/user', '/temp/']:
		for k in ['PhEDEx_Debug', 'LoadTest']:
			if k in ds:
				ignore = True
		if ignore:
			continue
		if ds.endswith('store'):
			continue
		if packages[ds]['size'] == 0:
			continue
		imbalance = {}#'avg': packages[ds]['size'] / packages[ds]['files']}
		for pool in sorted(pools):
			# positive => migrate towards, negative => migrate away
			pool_frac = pools[pool]['space']['total'] / pools_total
			ds_usage_optimum = packages[ds]['size'] * pool_frac
			imbalance[pool] = ds_usage_optimum - packages[ds].get(pool, 0)
		result[ds] = imbalance

	return result
